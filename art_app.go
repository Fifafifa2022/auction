/******************************************************************
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
******************************************************************/

///////////////////////////////////////////////////////////////////////
// Author : Mohan Venkataraman
// Purpose: Explore the Hyperledger/fabric and understand
// how to write and application, application/fabric boundaries
// The code is not the best as it has just hammered out in a day or two
// Feedback and updates are appreciated
///////////////////////////////////////////////////////////////////////

package main

import (
	"bufio"
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	"github.com/op/go-logging"
	"image"
	"image/png"
	"io"
	"net/http"
	"os"
	"os/exec"
	"runtime"
	"strconv"
	"strings"
	"time"
	//      "github.com/errorpkg"
	//      "image/png"
)

var recType = []string{"ARTINV", "USER", "BID", "AUCREQ", "POSTTRAN", "OPENAUC", "CLAUC"}
var aucTables = []string{"UserTable", "UserCatTable", "ItemTable", "ItemCatTable", "ItemHistoryTable", "AuctionTable", "AucInitTable", "AucOpenTable", "BidTable", "TransTable"}

///////////////////////////////////////////////////////////////////////////////////////
// ART Auction Functions
// This creates a record of the Asset (Inventory)
// Includes Description, title, certificate of authenticity
// Itemist date created etc.
// Example:
// Item { 113869, "Flower Urn on a Patio", "Liz Jardine", "10102007", "Original", "Floral", "Acrylic", "15 x 15 in", "sample_9.png","$600", "My Gallery }
///////////////////////////////////////////////////////////////////////////////////////

type ItemObject struct {
	ItemID         string
	RecType        string
	ItemDesc       string
	ItemDetail     string // Could included details such as who created the Art work if item is a Painting
	ItemDate       string
	ItemType       string
	ItemSubject    string
	ItemMedia      string
	ItemSize       string
	ItemPicFN      string
	ItemImage      []byte // This has to be generated AES encrypted using the file name
	AES_Key        []byte // This is generated by the AES Algorithms
	ItemImageType  string // should be used to regenerate the appropriate image type
	ItemBasePrice  string // Reserve Price at Auction must be greater than this price
	CurrentOwnerID string // This is validated for a user registered record
}

type ItemLog struct {
	ItemID       string // PRIMARY KEY
	Status       string // SECONDARY KEY - OnAuc, OnSale, NA
	AuctionedBy  string // SECONDARY KEY - Auction House ID if applicable
	RecType      string // ITEMHIS
	ItemDesc     string
	CurrentOwner string
	Date         string // Date when status changed
}

/////////////////////////////////////////////////////////////
// Create Buyer, Seller info, Auction House, Authenticator
/////////////////////////////////////////////////////////////
type UserObject struct {
	UserID    string
	RecType   string // Type = USER
	Name      string
	UserType  string // Auction House (AH), Bank (BK), Buyer or Seller (TRADER), Shipper (SH), Appraiser (AP)
	Address   string
	Phone     string
	Email     string
	Bank      string
	AccountNo string
	RoutingNo string
}

/////////////////////////////////////////////////////////////
//  Register a request for participating in an auction
/////////////////////////////////////////////////////////////

type AuctionRequest struct {
	AuctionID      string
	RecType        string // AUCREQ
	ItemID         string
	AuctionHouseID string // ID of the Auction House managing the auction
	SellerID       string // ID Of Seller - to verified against the Item CurrentOwnerId
	RequestDate    string // Date on which Auction Request was filed
	ReservePrice   string // reserver price > previous purchase price
	Status         string // INIT, OPEN, CLOSED (To be Updated by Trgger Auction)
	OpenDate       string // Date on which auction will occur (To be Updated by Trigger Auction)
	CloseDate      string // Date and time when Auction will close (To be Updated by Trigger Auction)
}

/////////////////////////////////////////////////////////////
// POST the transaction after the Auction Completes
// Post an Auction Transaction
// Post an Updated Item Object
/////////////////////////////////////////////////////////////

type ItemTransaction struct {
	AuctionID   string
	RecType     string // POSTTRAN
	ItemID      string
	TransType   string // Sale, Buy, Commission
	UserId      string // Buyer or Seller ID
	TransDate   string // Date of Settlement (Buyer or Seller)
	HammerTime  string // Time of hammer strike - SOLD
	HammerPrice string // Total Settlement price
	Details     string // Details about the Transaction
}

/////////////////////////////////////////////////////////////
//  Register a request for participating in an auction
/////////////////////////////////////////////////////////////

type Bid struct {
	AuctionID string
	RecType   string // BID
	BidNo     string
	ItemID    string
	BuyerID   string // ID Of Buyer - to verified against the Item CurrentOwnerId
	BidPrice  string // BidPrice > Previous Bid
	BidTime   string // Time the bid was received
}

//////////////////////////////////////////////////////////////
// A Map that holds TableNames and the number of Keys
// This information is used to dynamically Create, Update
// and Query the Ledger
//              "UserTable":        1, Key: UserID
//              "ItemTable":        1, Key: ItemID
//              "UserCatTable":     3, Key: "2016", UserType, UserID
//              "ItemCatTable":     3, Key: "2016", ItemSubject, ItemID
//              "AuctionTable":     1, Key: AuctionID
//              "AucInitTable":     2, Key: Year, AuctionID
//              "AucOpenTable":     2, Key: Year, AuctionID
//              "TransTable":       2, Key: AuctionID, ItemID
//              "BidTable":         2, Key: AuctionID, BidNo
//              "ItemHistoryTable": 3, Key: ItemID, Status, AuctionHouseID(if applicable)
//
//////////////////////////////////////////////////////////////

func GetNumberOfKeys(tname string) int {
	TableMap := map[string]int{
		"UserTable":        1,
		"ItemTable":        1,
		"UserCatTable":     3,
		"ItemCatTable":     3,
		"AuctionTable":     1,
		"AucInitTable":     2,
		"AucOpenTable":     2,
		"TransTable":       2,
		"BidTable":         2,
		"ItemHistoryTable": 3,
	}
	return TableMap[tname]
}

//////////////////////////////////////////////////////////////
// Invoke Functions based on Function name
//
//////////////////////////////////////////////////////////////
func InvokeFunction(fname string) func(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {
	InvokeFunc := map[string]func(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error){
		"PostItem":           PostItem,
		"PostUser":           PostUser,
		"PostAuctionRequest": PostAuctionRequest,
		"PostTransaction":    PostTransaction,
		"PostBid":            PostBid,
		"OpenAuctionForBids": OpenAuctionForBids,
		"CloseAuction":       CloseAuction,
	}
	return InvokeFunc[fname]
}

//////////////////////////////////////////////////////////////
// Query Functions based on Function name
//
//////////////////////////////////////////////////////////////
func QueryFunction(fname string) func(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {
	QueryFunc := map[string]func(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error){
		"GetItem":             GetItem,
		"GetUser":             GetUser,
		"GetAuctionRequest":   GetAuctionRequest,
		"GetTransaction":      GetTransaction,
		"GetBid":              GetBid,
		"GetLastBid":          GetLastBid,
		"GetHighestBid":       GetHighestBid,
		"GetNoOfBidsReceived": GetNoOfBidsReceived,
		"GetListOfBids":       GetListOfBids,
		"GetItemLog":          GetItemLog,
		"GetItemListByCat":    GetItemListByCat,
		"GetUserListByCat":    GetUserListByCat,
		"GetListOfItemsOnAuc": GetListOfItemsOnAuc,
		"GetListOfOpenAucs":   GetListOfOpenAucs,
	}
	return QueryFunc[fname]
}

var myLogger = logging.MustGetLogger("auction_trading")

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SimpleChaincode - Init Chaincode implementation - The following sequence of transactions can be used to test the Chaincode
// -----------------------------------------------------------------------------------
// This will fail first time as Owner ID 4200 will be missing in the block Chain
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "PostItem", "Args":["2000", "ARTINV", "Modern Item Female Portrait", "Ashley Barber", "10102015", "Original", "Nude", "Canvas", "15 x 15 in", "sample_7.png","$600", "4200"]}'
// -----------------------------------------------------------------------------------
// This transaction will insert User 4200 into the block chain
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "PostUserrecord", "Args":["4200", "USER", "Susans Item House", "AUCTION",  "One Cary Parkway, #216, Cary, NC 27512", "9198063535", "admin@itpeople.com", "BBT", "00017102345", "0234678"]}'
// -----------------------------------------------------------------------------------
// Inserts User 225 into Block Chain
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "PostUser", "Args":["225", "USER", "Random House", "AUCTION", "One Copley Parkway, #216, Morrisville, NC 27560", "9198063535", "admin@itpeople.com", "SUNTRUST", "00017102345", "0234678"]}'
// -----------------------------------------------------------------------------------
// This attempt will also fail as Picture file sample_9.png will be missing
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "PostItem", "Args":["2000", "ARTINV", "Modern Item Female Portrait", "Ashley Barber", "10102015", "Original", "Nude", "Canvas", "15 x 15 in", "sample_9.png","$600", "4200"]}'
// -----------------------------------------------------------------------------------
// This attempt will work as Picture file sample_7.png will be found in current directory
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "PostItem", "Args":["2000", "ARTINV", "Modern Item Female Portrait", "Ashley Barber", "10102015", "Original", "Nude", "Canvas", "15 x 15 in", "sample_7.png","$600", "4200"]}'
// -----------------------------------------------------------------------------------
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "PostItem", "Args":["2000", "ARTINV", "Modern Item Female Portrait", "Ashley Barber", "10102015", "Original", "Nude", "Canvas", "15 x 15 in", "sample_7.png","$600", "4200"]}'
//------------------------------------------------------------------------------------
// Create an Auction Request
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "PostAuctionRequest", "Args":["A01", "AUCREQ", "2000", "225", "4200", "04012016", "05312016","$1200"]}'
//------------------------------------------------------------------------------------
// Post a Transaction
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "PostTransaction", "Args":["A01", "POSTTRAN", "2000", "SALE", "320", "05312016","$2400","Sold to Private Collecter"]}'
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "PostTransaction", "Args": [1111 POSTTRAN 1000 SALE 400 2016-05-19 22:37:09 2016-05-19 22:37:09 8000 The Highest Bidder does not always win]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

type SimpleChaincode struct {
}

func (t *SimpleChaincode) Init(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	// TODO - Include all initialization to be complete before Invoke and Query
	myLogger.Info("[Trade and Auction Application] Init")
	var err error

	for _, val := range aucTables {
		err = stub.DeleteTable(val)
		err = InitLedger(stub, val)
		if err != nil {
			return nil, fmt.Errorf("Initiation of %s  Failed ", val)
		}
	}

	fmt.Printf("Init() Initialization Complete  : ", args)
	return []byte("Init(): Initialization Complete"), nil
}

/////////////////////////////////////////////////////////////////
// Checks if the incoming invoke has a valid requesType
// The Request type is used to process the record accordingly
/////////////////////////////////////////////////////////////////
func CheckRequestType(rt string) bool {
	for _, val := range recType {
		if val == rt {
			fmt.Printf("CheckRequestType() : Valid Request Type , val : ", val, rt, "\n")
			return true
		}
	}
	fmt.Printf("CheckRequestType() : Invalid Request Type , val : ", rt, "\n")
	return false
}

////////////////////////////////////////////////////////////////
// SimpleChaincode - INVOKE Chaincode implementation
// User Can Invoke
// - Create Auction Transaction
// - Create a Sell Transaction
// - Create a Buy Transaction
// - Authenticate Transaction
////////////////////////////////////////////////////////////////

func (t *SimpleChaincode) Invoke(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {
	var err error
	var buff []byte

	// Check Type of Transaction and apply business rules
	// before adding record to the block chain

	if CheckRequestType(args[1]) == true {

		InvokeRequest := InvokeFunction(function)
		if InvokeRequest != nil {
			buff, err = InvokeRequest(stub, function, args)
		}
	} else {
		//errorpkg.HandleError(7, "Invoke(): Invalid recType : " + args[1])
		fmt.Printf("Invoke() Invalid recType : " + args[1] + "\n")
		return nil, errors.New("Invoke() : Invalid recType : " + args[1])
	}

	return buff, err
}

////////////////////////////////////////////////////////////////
// SimpleChaincode - QUERY Chaincode implementation
// User Can Query
// - get Auction Transaction
// - get a Sell Transaction
// - get a Buy Transaction
// - get the auction closeout Transaction
// Sample Data
// ./peer chaincode query -l golang -n mycc -c '{"Function": "Getuser", "Args": ["4000"]}'
// ./peer chaincode query -l golang -n mycc -c '{"Function": "Getuser", "Args": ["300"]}'
// ./peer chaincode query -l golang -n mycc -c '{"Function": "GetItem", "Args": ["2000"]}'
////////////////////////////////////////////////////////////////

func (t *SimpleChaincode) Query(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {
	var err error
	var buff []byte
	fmt.Printf("ID Extracted and Type = ", args[0])
	fmt.Printf("Args supplied : ", args)

	if len(args) < 1 {
		fmt.Printf("Query() : Include at least 1 arguments Key \n")
		return nil, errors.New("Query() : Expecting Transation type and Key value for query")
	}

	fmt.Printf("Query() : Query Key = %s & Function  = %s    \n", args[0], function)

	QueryRequest := QueryFunction(function)
	if QueryRequest != nil {
		buff, err = QueryRequest(stub, function, args)
	} else {
		fmt.Printf("Query() Invalid recType : " + function + "\n")
		return nil, errors.New("Query() : Invalid function call : " + function)
	}
	if err != nil {
		fmt.Printf("Query() Object not found : " + args[0] + "\n")
		return nil, errors.New("Query() : Object not found : " + args[0])
	}
	return buff, err
}

////////////////////////////////////////////////////////////////////
// Retrieve User Information
//
////////////////////////////////////////////////////////////////////
func GetUser(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	var err error

	// Get the Objects and Display it
	Avalbytes, err := QueryLedger(stub, "UserTable", args)
	if err != nil {
		fmt.Printf("GetUser() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	if Avalbytes == nil {
		fmt.Printf("GetUser() : Incomplete Query Object ")
		jsonResp := "{\"Error\":\"Incomplete information about the key for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Printf("GetUser() : Response : Successfull - \n")
	return Avalbytes, nil
}

////////////////////////////////////////////////////////////////////
// Query callback representing the query of a chaincode
// Retrieve a transaction by transaction ID
////////////////////////////////////////////////////////////////////
func GetItem(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	var err error

	// Get the Objects and Display it
	Avalbytes, err := QueryLedger(stub, "ItemTable", args)
	if err != nil {
		fmt.Printf("GetItem() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	if Avalbytes == nil {
		fmt.Printf("GetItem() : Incomplete Query Object ")
		jsonResp := "{\"Error\":\"Incomplete information about the key for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Printf("GetItem() : Response : Successfull - \n")
	return Avalbytes, nil
}

////////////////////////////////////////////////////////////////////
// Retrieve Auction Information
//
////////////////////////////////////////////////////////////////////
func GetAuctionRequest(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	var err error

	// Get the Objects and Display it
	Avalbytes, err := QueryLedger(stub, "AuctionTable", args)
	if err != nil {
		fmt.Printf("GetAuctionRequest() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	if Avalbytes == nil {
		fmt.Printf("GetAuctionRequest() : Incomplete Query Object ")
		jsonResp := "{\"Error\":\"Incomplete information about the key for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Printf("GetAuctionRequest() : Response : Successfull - \n")
	return Avalbytes, nil
}

////////////////////////////////////////////////////////////////////
// Retrieve a Bid based on two keys - AucID, BidNo
//
////////////////////////////////////////////////////////////////////
func GetBid(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	var err error

	// Check there are 2 Arguments provided as per the the struct - two are computed
	// See example
	if len(args) < 2 {
		fmt.Println("GetBid(): Incorrect number of arguments. Expecting 2 ")
		fmt.Println("GetBid(): ./peer chaincode query -l golang -n mycc -c '{\"Function\": \"GetBid\", \"Args\": [\"1111\",\"6\"]}'")
		return nil, errors.New("CreateItemObject(): Incorrect number of arguments. Expecting 2 ")
	}

	// Get the Objects and Display it
	Avalbytes, err := QueryLedger(stub, "BidTable", args)
	if err != nil {
		fmt.Printf("GetBid() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	if Avalbytes == nil {
		fmt.Printf("GetBid() : Incomplete Query Object ")
		jsonResp := "{\"Error\":\"Incomplete information about the key for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Printf("GetBid() : Response : Successfull - \n")
	return Avalbytes, nil
}

////////////////////////////////////////////////////////////////////
// Retrieve Auction Closeout Information
//
////////////////////////////////////////////////////////////////////
func GetTransaction(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	//var err error

	// Get the Objects and Display it
	Avalbytes, err := QueryLedger(stub, "TransTable", args)
	if Avalbytes == nil {
		fmt.Printf("GetTransaction() : Incomplete Query Object ")
		jsonResp := "{\"Error\":\"Incomplete information about the key for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	if err != nil {
		fmt.Printf("GetTransaction() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Printf("GetTransaction() : Response : Successfull - \n")
	return Avalbytes, nil
}

///////////////////////////////////////////////////////////////////////
// Checks if the ART Work Is Valid
// The User Provides an Authentication Key which is used to
// Retrieve the ART Object and Validate if it is as represented by the
// Seller
///////////////////////////////////////////////////////////////////////
func (t *SimpleChaincode) AuthenticateItem(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {
	return nil, nil
}

//////////////////////////////////////////////////////
// Chain Code Kick-off Main function
//////////////////////////////////////////////////////
func main() {

	// maximize CPU usage for maximum performance
	runtime.GOMAXPROCS(runtime.NumCPU())
	fmt.Println("Starting Item Auction Application chaincode ver 13 Dated 2016-06-06 17.00.00: ")

	// Start the shim -- running the fabric
	err := shim.Start(new(SimpleChaincode))
	if err != nil {
		fmt.Printf("Error starting Item Fun Application chaincode: %s", err)
	}

}

//////////////////////////////////////////////////////////////////////
// Create a master Object of the Item
// Since the Owner Changes hands, a record has to be written for each
// Transaction with the updated Encryption Key of the new owner
//////////////////////////////////////////////////////////////////////

func PostItem(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	if function != "PostItem" {
		return nil, errors.New("PostItem(): Invalid function name. Expecting \"PostItem\"")
	}

	itemObject, err := CreateItemObject(args[0:]) //
	if err != nil {
		fmt.Printf("getObjectBuffer(): Cannot create itemObject \n")
		return nil, err
	}

	ownerInfo, err := ValidateMember(stub, itemObject.CurrentOwnerID)
	fmt.Printf("Owner information  ", ownerInfo, itemObject.CurrentOwnerID)
	if err != nil {
		fmt.Printf("getObjectBuffer() : Failed Owner information not found for ", itemObject.CurrentOwnerID)
		return nil, err
	}

	fmt.Printf("PostItem() : Owner info : ", ownerInfo)
	buff, err := ARtoJSON(itemObject) //
	if err != nil {
		fmt.Printf("PostItem() : Failed Cannot create object buffer for write : " + args[1] + "\n")
		return nil, errors.New("PostItem(): Failed Cannot create object buffer for write : " + args[1])
	} else {
		// Update the ledger with the Buffer Data
		// err = stub.PutState(args[0], buff)
		keys := []string{args[0]}
		err = UpdateLedger(stub, "ItemTable", keys, buff)
		if err != nil {
			fmt.Printf("PostItem() : write error while inserting record\n")
			return buff, err
		}

		_, err = PostItemLog(stub, itemObject, "INITIAL", "DEFAULT")
		if err != nil {
			fmt.Printf("PostItemLog() : write error while inserting record\n")
			return nil, err
		}

		// Post Entry into ItemCatTable - i.e. Item Category Table
		// The first key 2016 is a dummy key to extract all values
		keys = []string{"2016", args[6], args[0]}
		err = UpdateLedger(stub, "ItemCatTable", keys, buff)
		if err != nil {
			fmt.Printf("PostItem() : write error while inserting record into ItemCatTable \n")
			return buff, err
		}

	}
	return buff, nil
}

func CreateItemObject(args []string) (ItemObject, error) {

	var err error
	var myItem ItemObject

	// Check there are 12 Arguments provided as per the the struct - two are computed
	// See example
	if len(args) != 12 {
		fmt.Println("CreateItemObject(): Incorrect number of arguments. Expecting 12 ")
		return myItem, errors.New("CreateItemObject(): Incorrect number of arguments. Expecting 12 ")
	}

	// Validate ItemID is an integer

	_, err = strconv.Atoi(args[0])
	if err != nil {
		fmt.Println("CreateItemObject(): ART ID should be an integer create failed! ")
		return myItem, errors.New("CreateItemObject(): ART ID should be an integer create failed!")
	}

	// Validate Picture File exists based on the name
	// Looks for file in current directory of application and must be fixed for other locations
	if _, err := os.Stat(args[9]); err == nil {
		fmt.Println(args[9], "  exists!")
	} else {
		fmt.Printf("CreateItemObject(): Cannot find Picture File = %s \n", args[9])
		return myItem, errors.New("CreateItemObject(): ART Picture File not found " + args[9])
	}

	// Get the Item Image
	imagebytes, fileType := imageToByteArray(args[9])
	// Insert logic to encrypt image

	AES_key, _ := GenAESKey()
	AES_enc := Encrypt(AES_key, imagebytes)

	myItem = ItemObject{args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], AES_enc, AES_key, fileType, args[10], args[11]}
	fmt.Println("CreateItemObject(): Item Object created: ", myItem.ItemID, myItem.AES_Key)

	// Code to Validate the Item Object)
	// If User presents Crypto Key then key is used to validate the picture that is stored as part of the title
	// TODO

	return myItem, nil
}

//////////////////////////////////////////////////////////////////////
// Create a master Object of the User
// Since the Owner Changes hands, a record has to be written for each
// Transaction with the updated Encryption Key of the new owner
//////////////////////////////////////////////////////////////////////

func UpdateItemObject(stub *shim.ChaincodeStub, ar []byte, hammerPrice string, buyer string) ([]byte, error) {

	var err error
	myItem, err := JSONtoAR(ar)
	if err != nil {
		fmt.Printf("U() : UpdateItemObject() : Failed to create Art Record Object from JSON ")
		return nil, err
	}

	// Insert logic to encrypt image
	CurrentAES_Key := myItem.AES_Key
	// Decrypt Image and Save Image in a file
	image := Decrypt(CurrentAES_Key, myItem.ItemImage)

	// Get New Key & Encrypt Image with New Key
	myItem.AES_Key, _ = GenAESKey()
	myItem.ItemImage = Encrypt(myItem.AES_Key, image)
	myItem.ItemBasePrice = hammerPrice
	myItem.CurrentOwnerID = buyer

	ar, err = ARtoJSON(myItem)
	keys := []string{myItem.ItemID, myItem.CurrentOwnerID}
	err = ReplaceLedgerEntry(stub, "ItemTable", keys, ar)
	if err != nil {
		fmt.Printf("UpdateItemObject() : Failed ReplaceLedgerEntry in ItemTable into Blockchain ")
		return nil, err
	}
	fmt.Printf("UpdateItemObject() : ReplaceLedgerEntry in ItemTable successful ")

	keys = []string{"2016", myItem.ItemSubject, myItem.ItemID}
	err = ReplaceLedgerEntry(stub, "ItemCatTable", keys, ar)
	if err != nil {
		fmt.Printf("UpdateItemObject() : Failed ReplaceLedgerEntry in ItemCategoryTable into Blockchain ")
		return nil, err
	}
	fmt.Printf("UpdateItemObject() : ReplaceLedgerEntry in ItemCategoryTable successful ")
	return myItem.AES_Key, nil
}

//////////////////////////////////////////////////////////////////////
// POSTS A LOG ENTRY Every Time the Item is transacted
// Valid Status for ItemLog =  OnAuc, OnSale, NA, INITIAL
// Valid AuctionedBy: This value is DEFAULT unless it is on Auction
//////////////////////////////////////////////////////////////////////

func PostItemLog(stub *shim.ChaincodeStub, item ItemObject, status string, ah string) ([]byte, error) {

	iLog := ItemToItemLog(item)
	iLog.Status = status
	iLog.AuctionedBy = ah

	buff, err := ItemLogtoJSON(iLog)
	if err != nil {
		fmt.Printf("PostItemLog() : Failed Cannot create object buffer for write : " + item.ItemID + "\n")
		return nil, errors.New("PostItemLog(): Failed Cannot create object buffer for write : " + item.ItemID)
	} else {
		// Update the ledger with the Buffer Data
		keys := []string{iLog.ItemID, iLog.Status, iLog.AuctionedBy}
		err = UpdateLedger(stub, "ItemHistoryTable", keys, buff)
		if err != nil {
			fmt.Printf("PostItem() : write error while inserting record\n")
			return buff, err
		}
	}
	return buff, nil
}

//////////////////////////////////////////////////////////
// Create a master Object of the Item
// Since the Owner Changes hands, a record is written for each
// Transaction
////////////////////////////////////////////////////////////

func PostUser(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	if function != "PostUser" {
		return nil, errors.New("PostUser(): Invalid function name. Expecting \"PostUserrecord\"")
	}
	record, err := CreateUserObject(args[0:]) //
	if err != nil {
		return nil, err
	}
	buff, err := UsertoJSON(record) //

	if err != nil {
		fmt.Printf("PostuserObject() : Failed Cannot create object buffer for write : " + args[1] + "\n")
		return nil, errors.New("PostUser(): Failed Cannot create object buffer for write : " + args[1])
	} else {
		// Update the ledger with the Buffer Data
		// err = stub.PutState(args[0], buff)
		keys := []string{args[0]}
		err = UpdateLedger(stub, "UserTable", keys, buff)
		if err != nil {
			fmt.Printf("PostUser() : write error while inserting record\n")
			return nil, err
		}

		// Post Entry into UserCatTable - i.e. User Category Table
		keys = []string{"2016", args[3], args[0]}
		err = UpdateLedger(stub, "UserCatTable", keys, buff)
		if err != nil {
			fmt.Printf("PostUser() : write error while inserting recordinto UserCatTable \n")
			return nil, err
		}
	}

	return buff, err
}

func CreateUserObject(args []string) (UserObject, error) {
	var err error
	var aUser UserObject

	// Check there are 11 Arguments
	// See example
	if len(args) != 10 {
		fmt.Println("CreateUserObject(): Incorrect number of arguments. Expecting 10 ")
		return aUser, errors.New("CreateUserObject() : Incorrect number of arguments. Expecting 10 ")
	}

	// Validate UserID is an integer

	_, err = strconv.Atoi(args[0])
	if err != nil {
		return aUser, errors.New("CreateUserObject() : User ID should be an integer")
	}

	// Validate Picture File exists
	// Replace this with imageToByteArray(filename)

	aUser = UserObject{args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]}
	fmt.Println("CreateUserObject() : User Object : ", aUser)
	// Code to Validate the User Object)
	// If User presents Crypto Key then key is used to validate
	// the picture that is stored as part of the User Identification
	// TODO in Future

	return aUser, nil
}

//////////////////////////////////////////////////////////
// Create an Auction Request
//
////////////////////////////////////////////////////////////

func PostAuctionRequest(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	if function != "PostAuctionRequest" {
		return nil, errors.New("PostAuctionRequest(): Invalid function name. Expecting \"PostAuctionRequest\"")
	}

	ar, err := CreateAuctionRequest(args[0:]) //
	if err != nil {
		return nil, err
	}

	// Validate Auction House
	aucHouse, err := ValidateMember(stub, ar.AuctionHouseID)
	fmt.Printf("Auction House information  ", aucHouse, ar.AuctionHouseID)
	if err != nil {
		fmt.Printf("PostAuctionRequest() : Failed Auction House not Registered in Blockchain ", ar.AuctionHouseID)
		return nil, err
	}

	fmt.Printf("getObjectBuffer() : Auction House info : ", aucHouse)

	// Validate Item record
	itemObject, err := ValidateItemSubmission(stub, ar.ItemID)
	if err != nil {
		fmt.Printf("PostAuctionRequest() : Failed Could not Validate Item Object in Blockchain ", ar.ItemID)
		return itemObject, err
	}

	fmt.Printf("getObjectBuffer() : Item info Authenticated : ", ar.ItemID)
	buff, err := AucReqtoJSON(ar) // Converting the auction request struct to []byte array
	if err != nil {
		fmt.Printf("PostAuctionRequest() : Failed Cannot create object buffer for write : " + args[1] + "\n")
		return nil, errors.New("PostAuctionRequest(): Failed Cannot create object buffer for write : " + args[1])
	} else {
		// Update the ledger with the Buffer Data
		//err = stub.PutState(args[0], buff)
		keys := []string{args[0]}
		err = UpdateLedger(stub, "AuctionTable", keys, buff)
		if err != nil {
			fmt.Println("PostAuctionRequest() : write error while inserting record, Error: ", err)
			return buff, err
		}

		// Post an Item Log
		io, err := JSONtoAR(itemObject)
		_, err = PostItemLog(stub, io, "ReadyForAuc", ar.AuctionHouseID)
		if err != nil {
			fmt.Printf("PostItemLog() : write error while inserting record\n")
			return buff, err
		}

		keys = []string{"2016", args[0]}
		err = UpdateLedger(stub, "AucInitTable", keys, buff)
		if err != nil {
			fmt.Printf("PostAuctionRequest() : write error while inserting record into AucInitTable \n")
			return buff, err
		}

	}

	return buff, err
}

func CreateAuctionRequest(args []string) (AuctionRequest, error) {
	var err error
	var aucReg AuctionRequest

	// Check there are 10 Arguments
	// See example -- The Open and Close Dates are Dummy, and will be set by trigger auction
	// '{"Function": "PostAuctionRequest", "Args":["1111", "AUCREQ", "1000", "200", "100", "04012016", "1200",
	//   "INIT", "2016-05-20 11:00:00.3 +0000 UTC","2016-05-23 11:00:00.3 +0000 UTC"]}'
	if len(args) != 10 {
		fmt.Println("CreateAuctionRegistrationObject(): Incorrect number of arguments. Expecting 10 ")
		return aucReg, errors.New("CreateAuctionRegistrationObject() : Incorrect number of arguments. Expecting 10 ")
	}

	// Validate UserID is an integer

	err = validateID(args[0])
	if err != nil {
		return aucReg, errors.New("CreateAuctionRegistrationObject() : User ID should be an integer")
	}

	aucReg = AuctionRequest{args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]}
	fmt.Println("CreateAuctionObject() : Auction Registration : ", aucReg)

	return aucReg, nil
}

//////////////////////////////////////////////////////////
// Create an Item Transaction record to process Request
//
////////////////////////////////////////////////////////////
func PostTransaction(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	if function != "PostTransaction" {
		return nil, errors.New("PostTransaction(): Invalid function name. Expecting \"PostTransaction\"")
	}

	ar, err := CreateTransactionRequest(args[0:]) //
	if err != nil {
		return nil, err
	}

	// Validate buyer's ID
	buyer, err := ValidateMember(stub, ar.UserId)
	if err != nil {
		fmt.Printf("PostTransaction() : Failed Buyer not Registered in Blockchain ", ar.UserId)
		return nil, err
	}

	fmt.Printf("PostTransaction(): Validated Buyer information successfully ", buyer, ar.UserId)

	// Validate Item record
	lastUpdatedItemOBCObject, err := ValidateItemSubmission(stub, ar.ItemID)
	if err != nil {
		fmt.Printf("PostTransaction() : Failed Could not Validate Item Object in Blockchain ", ar.ItemID)
		return lastUpdatedItemOBCObject, err
	}
	fmt.Printf("PostTransaction() : Validated Item Object in Blockchain successfully", ar.ItemID)

	// Update Item Object with new Owner Key
	newKey, err := UpdateItemObject(stub, lastUpdatedItemOBCObject, ar.HammerPrice, ar.UserId)
	if err != nil {
		fmt.Printf("PostTransaction() : Failed to update Item Master Object in Blockchain ", ar.ItemID)
		return nil, err
	} else {
		// Write New Key to file
		fmt.Printf("PostTransaction() : New encryption Key is  ", newKey)
	}
	fmt.Printf("PostTransaction() : Updated Item Master Object in Blockchain successfully", ar.ItemID)

	// Post an Item Log
	itemObject, err := JSONtoAR(lastUpdatedItemOBCObject)
	if err != nil {
		fmt.Printf("PostTransaction() : Conversion error JSON to ItemRecord\n")
		return lastUpdatedItemOBCObject, err
	}

	itemObject.ItemBasePrice = ar.HammerPrice
	itemObject.CurrentOwnerID = ar.UserId

	_, err = PostItemLog(stub, itemObject, "NA", "DEFAULT")
	if err != nil {
		fmt.Printf("PostTransaction() : write error while inserting item log record\n")
		return lastUpdatedItemOBCObject, err
	}

	fmt.Printf("PostTransaction() : Inserted item log record successfully", ar.ItemID)

	// Return processed Transaction for Update
	buff, err := TrantoJSON(ar) //
	if err != nil {
		fmt.Printf("GetObjectBuffer() : Failed to convert Transaction Object to JSON ", args[0])
		return nil, err
	}

	// Update the ledger with the Buffer Data
	keys := []string{args[0], args[3]}
	err = UpdateLedger(stub, "TransTable", keys, buff)
	if err != nil {
		fmt.Printf("PostTransaction() : write error while inserting record\n")
		return buff, err
	}

	fmt.Printf("PostTransaction() : Posted Transaction Record successfully\n")

	return buff, err
}

func CreateTransactionRequest(args []string) (ItemTransaction, error) {

	var at ItemTransaction

	// Check there are 9 Arguments
	if len(args) != 9 {
		fmt.Println("CreateTransactionRequest(): Incorrect number of arguments. Expecting 9 ")
		return at, errors.New("CreateTransactionRequest() : Incorrect number of arguments. Expecting 9 ")
	}

	at = ItemTransaction{args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]}
	fmt.Println("CreateTransactionRequest() : Transaction Request: ", at)

	return at, nil
}

//////////////////////////////////////////////////////////
// Create a Bid Object
//
//
////////////////////////////////////////////////////////////

func PostBid(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	if function != "PostBid" {
		return nil, errors.New("PostBid(): Invalid function name. Expecting \"PostBid\"")
	}
	record, err := CreateBidObject(args[0:]) //
	if err != nil {
		return nil, err
	}

	// Reject the Bid if the Buyer Information Is nor Valid or not registered on the Block Chain
	buyerInfo, err := ValidateMember(stub, args[4])
	fmt.Printf("Buyer information  ", buyerInfo, args[4])
	if err != nil {
		fmt.Printf("PostBid() : Failed Buyer not registered on the block-chain ", args[4])
		return nil, err
	}

	// Reject Bid if Auction is not OPEN (The OpenAuctionForBids automatically updates Auction to Close
	// On Timer expiry
	RBytes, err := GetAuctionRequest(stub, "GetAuctionRequest", []string{args[0]})
	if err != nil {
		fmt.Printf("PostBid() : Cannot find Auction record ", args[0])
		return nil, errors.New("PostBid(): Cannot find Auction record : " + args[0])
	}
	aucR, err := JSONtoAucReq(RBytes)
	if err != nil {
		fmt.Printf("PostBid() : Cannot UnMarshall Auction record")
		return nil, errors.New("PostBid(): Cannot UnMarshall Auction record: " + args[0])
	}
	if aucR.Status != "OPEN" {
		fmt.Printf("PostBid() : Cannot accept Bid as Auction is not OPEN ", args[0])
		return nil, errors.New("PostBid(): Cannot accept Bid as Auction is not OPEN : " + args[0])
	}

	buff, err := BidtoJSON(record) //

	if err != nil {
		fmt.Printf("PostBid() : Failed Cannot create object buffer for write : " + args[1] + "\n")
		return nil, errors.New("PostBid(): Failed Cannot create object buffer for write : " + args[1])
	} else {
		// Update the ledger with the Buffer Data
		// err = stub.PutState(args[0], buff)
		keys := []string{args[0], args[2]}
		err = UpdateLedger(stub, "BidTable", keys, buff)
		if err != nil {
			fmt.Printf("PostBidTable() : write error while inserting record\n")
			return buff, err
		}
	}

	return buff, err
}

func CreateBidObject(args []string) (Bid, error) {
	var err error
	var aBid Bid

	// Check there are 11 Arguments
	// See example
	if len(args) != 6 {
		fmt.Println("CreateBidObject(): Incorrect number of arguments. Expecting 6 ")
		return aBid, errors.New("CreateBidObject() : Incorrect number of arguments. Expecting 6 ")
	}

	// Validate Bid is an integer

	_, err = strconv.Atoi(args[0])
	if err != nil {
		return aBid, errors.New("CreateBidObject() : Bid ID should be an integer")
	}

	_, err = strconv.Atoi(args[2])
	if err != nil {
		return aBid, errors.New("CreateBidObject() : Bid ID should be an integer")
	}

	bidTime := time.Now().Format("2006-01-02 15:04:05")

	aBid = Bid{args[0], args[1], args[2], args[3], args[4], args[5], bidTime}
	fmt.Println("CreateBidObject() : Bid Object : ", aBid)

	return aBid, nil
}

//////////////////////////////////////////////////////////
// Validate and Authenticate ART Work and ownership
// Check if owner has the right key to the work
// Haven't thought through as to how to model
//////////////////////////////////////////////////////////
func authenticateItemOwnership(buyerId string, privKey string) error {

	// TODO - IS THIS NEEDED
	return nil
}

///////////////////////////////////////////////////////////
// Convert Image to []bytes and viceversa
// Detect Image Filetype
// Image Function to read an image and create a byte array
///////////////////////////////////////////////////////////
func imageToByteArray(imageFile string) ([]byte, string) {

	file, err := os.Open(imageFile)

	if err != nil {
		fmt.Printf("imageToByteArray() : cannot OPEN image file ", err)
		return nil, string("imageToByteArray() : cannot OPEN image file ")
	}

	defer file.Close()

	fileInfo, _ := file.Stat()
	var size int64 = fileInfo.Size()
	bytes := make([]byte, size)

	// read file into bytes
	buff := bufio.NewReader(file)
	_, err = buff.Read(bytes)

	if err != nil {
		fmt.Printf("imageToByteArray() : cannot READ image file")
		return nil, string("imageToByteArray() : cannot READ image file ")
	}

	filetype := http.DetectContentType(bytes)
	fmt.Printf("imageToByteArray() : ", filetype)
	//filetype := GetImageType(bytes)

	return bytes, filetype
}

//////////////////////////////////////////////////////
// If Valid fileType, will have "image" as first word
//////////////////////////////////////////////////////
func GetImageType(buff []byte) string {
	filetype := http.DetectContentType(buff)

	switch filetype {
	case "image/jpeg", "image/jpg":
		return filetype

	case "image/gif":
		return filetype

	case "image/png":
		return filetype

	case "application/pdf": // not image, but application !
		filetype = "application/pdf"
	default:
		filetype = "Unknown"
	}
	return filetype
}

////////////////////////////////////////////////////////////
// Converts a byteArray into an image and saves it
// into an appropriate file
// It is important to get the file type before saving the
// file by call the GetImageType
////////////////////////////////////////////////////////////
func ByteArrayToImage(imgByte []byte, imageFile string) error {

	// convert []byte to image for saving to file
	img, _, _ := image.Decode(bytes.NewReader(imgByte))

	fmt.Printf("ProcessQueryResult ByteArrayToImage : proceeding to create image ")

	//save the imgByte to file
	out, err := os.Create(imageFile)

	if err != nil {
		fmt.Println("ByteArrayToImage() : cannot CREATE image file ", err)
		return errors.New("ByteArrayToImage() : cannot CREATE image file ")
	}
	fmt.Printf("ProcessRequestType ByteArrayToImage : proceeding to Encode image ")

	err = png.Encode(out, img)

	if err != nil {
		fmt.Println("ByteArrayToImage() : cannot ENCODE image file ", err)
		return errors.New("ByteArrayToImage() : cannot ENCODE image file ")
	}

	// everything ok
	fmt.Println("Image file  generated and saved to ", imageFile)
	return nil
}

///////////////////////////////////////////////////////////////////////
// Encryption and Decryption Section
// Images will be Encrypted and stored and the key will be part of the
// certificate that is provided to the Owner
///////////////////////////////////////////////////////////////////////

const (
	AESKeyLength = 32 // AESKeyLength is the default AES key length
	NonceSize    = 24 // NonceSize is the default NonceSize
)

///////////////////////////////////////////////////
// GetRandomBytes returns len random looking bytes
///////////////////////////////////////////////////
func GetRandomBytes(len int) ([]byte, error) {
	key := make([]byte, len)

	_, err := rand.Read(key)
	if err != nil {
		return nil, err
	}

	return key, nil
}

////////////////////////////////////////////////////////////
// GenAESKey returns a random AES key of length AESKeyLength
// 3 Functions to support Encryption and Decryption
// GENAESKey() - Generates AES symmetric key
// Encrypt() Encrypts a [] byte
// Decrypt() Decryts a [] byte
////////////////////////////////////////////////////////////
func GenAESKey() ([]byte, error) {
	return GetRandomBytes(AESKeyLength)
}

func PKCS5Pad(src []byte) []byte {
	padding := aes.BlockSize - len(src)%aes.BlockSize
	pad := bytes.Repeat([]byte{byte(padding)}, padding)
	return append(src, pad...)
}

func PKCS5Unpad(src []byte) []byte {
	len := len(src)
	unpad := int(src[len-1])
	return src[:(len - unpad)]
}

func Decrypt(key []byte, ciphertext []byte) []byte {

	// Create the AES cipher
	block, err := aes.NewCipher(key)
	if err != nil {
		panic(err)
	}

	// Before even testing the decryption,
	// if the text is too small, then it is incorrect
	if len(ciphertext) < aes.BlockSize {
		panic("Text is too short")
	}

	// Get the 16 byte IV
	iv := ciphertext[:aes.BlockSize]

	// Remove the IV from the ciphertext
	ciphertext = ciphertext[aes.BlockSize:]

	// Return a decrypted stream
	stream := cipher.NewCFBDecrypter(block, iv)

	// Decrypt bytes from ciphertext
	stream.XORKeyStream(ciphertext, ciphertext)

	return ciphertext
}

func Encrypt(key []byte, ba []byte) []byte {

	// Create the AES cipher
	block, err := aes.NewCipher(key)
	if err != nil {
		panic(err)
	}

	// Empty array of 16 + ba length
	// Include the IV at the beginning
	ciphertext := make([]byte, aes.BlockSize+len(ba))

	// Slice of first 16 bytes
	iv := ciphertext[:aes.BlockSize]

	// Write 16 rand bytes to fill iv
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		panic(err)
	}

	// Return an encrypted stream
	stream := cipher.NewCFBEncrypter(block, iv)

	// Encrypt bytes from ba to ciphertext
	stream.XORKeyStream(ciphertext[aes.BlockSize:], ba)

	return ciphertext
}

//////////////////////////////////////////////////////////
// JSON To args[]
//////////////////////////////////////////////////////////
func JSONtoArgs(Avalbytes []byte) (map[string]interface{}, error) {

	var data map[string]interface{}

	if err := json.Unmarshal(Avalbytes, &data); err != nil {
		return nil, err
	}

	return data, nil
}

//////////////////////////////////////////////////////////
// Converts JSON String to an ART Object
//////////////////////////////////////////////////////////
func JSONtoAR(data []byte) (ItemObject, error) {

	ar := ItemObject{}
	err := json.Unmarshal([]byte(data), &ar)
	if err != nil {
		fmt.Println("Unmarshal failed : ", err)
	}

	return ar, err
}

//////////////////////////////////////////////////////////
// Converts an ART Object to a JSON String
//////////////////////////////////////////////////////////
func ARtoJSON(ar ItemObject) ([]byte, error) {

	ajson, err := json.Marshal(ar)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	return ajson, nil
}

//////////////////////////////////////////////////////////
// Converts an BID to a JSON String
//////////////////////////////////////////////////////////
func ItemLogtoJSON(item ItemLog) ([]byte, error) {

	ajson, err := json.Marshal(item)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	return ajson, nil
}

//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoItemLog(ithis []byte) (ItemLog, error) {

	item := ItemLog{}
	err := json.Unmarshal(ithis, &item)
	if err != nil {
		fmt.Println("JSONtoAucReq error: ", err)
		return item, err
	}
	return item, err
}

//////////////////////////////////////////////////////////
// Converts an Auction Request to a JSON String
//////////////////////////////////////////////////////////
func AucReqtoJSON(ar AuctionRequest) ([]byte, error) {

	ajson, err := json.Marshal(ar)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	return ajson, nil
}

//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoAucReq(areq []byte) (AuctionRequest, error) {

	ar := AuctionRequest{}
	err := json.Unmarshal(areq, &ar)
	if err != nil {
		fmt.Println("JSONtoAucReq error: ", err)
		return ar, err
	}
	return ar, err
}

//////////////////////////////////////////////////////////
// Converts an BID to a JSON String
//////////////////////////////////////////////////////////
func BidtoJSON(myHand Bid) ([]byte, error) {

	ajson, err := json.Marshal(myHand)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	return ajson, nil
}

//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoBid(areq []byte) (Bid, error) {

	myHand := Bid{}
	err := json.Unmarshal(areq, &myHand)
	if err != nil {
		fmt.Println("JSONtoAucReq error: ", err)
		return myHand, err
	}
	return myHand, err
}

//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func UsertoJSON(user UserObject) ([]byte, error) {

	ajson, err := json.Marshal(user)
	if err != nil {
		fmt.Println("UsertoJSON error: ", err)
		return nil, err
	}
	fmt.Println("UsertoJSON created: ", ajson)
	return ajson, nil
}

//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoUser(user []byte) (UserObject, error) {

	ur := UserObject{}
	err := json.Unmarshal(user, &ur)
	if err != nil {
		fmt.Println("UsertoJSON error: ", err)
		return ur, err
	}
	fmt.Println("UsertoJSON created: ", ur)
	return ur, err
}

//////////////////////////////////////////////////////////
// Converts an Item Transaction to a JSON String
//////////////////////////////////////////////////////////
func TrantoJSON(at ItemTransaction) ([]byte, error) {

	ajson, err := json.Marshal(at)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	return ajson, nil
}

//////////////////////////////////////////////////////////
// Converts an Trans Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoTran(areq []byte) (ItemTransaction, error) {

	at := ItemTransaction{}
	err := json.Unmarshal(areq, &at)
	if err != nil {
		fmt.Println("JSONtoTran error: ", err)
		return at, err
	}
	return at, err
}

//////////////////////////////////////////////
// Validates an ID for Well Formed
//////////////////////////////////////////////

func validateID(id string) error {
	// Validate UserID is an integer

	_, err := strconv.Atoi(id)
	if err != nil {
		return errors.New("validateID(): User ID should be an integer")
	}
	return nil
}

//////////////////////////////////////////////
// Create an ItemLog from Item
//////////////////////////////////////////////

func ItemToItemLog(io ItemObject) ItemLog {

	iLog := ItemLog{}
	iLog.ItemID = io.ItemID
	iLog.Status = "INITIAL"
	iLog.AuctionedBy = "DEFAULT"
	iLog.RecType = "ILOG"
	iLog.ItemDesc = io.ItemDesc
	iLog.CurrentOwner = io.CurrentOwnerID
	iLog.Date = time.Now().Format("2006-01-02 15:04:05")

	return iLog
}

//////////////////////////////////////////////
// Convert Bid to Transaction for Posting
//////////////////////////////////////////////

func BidtoTransaction(bid Bid) ItemTransaction {

	var t ItemTransaction
	t.AuctionID = bid.AuctionID
	t.RecType = "POSTTRAN"
	t.ItemID = bid.ItemID
	t.TransType = "SALE"
	t.UserId = bid.BuyerID
	t.TransDate = time.Now().Format("2006-01-02 15:04:05")
	t.HammerTime = bid.BidTime
	t.HammerPrice = bid.BidPrice
	t.Details = "The Highest Bidder does not always win"

	return t
}

////////////////////////////////////////////////////////////////////////////
// Validate if the User Information Exists
// in the block-chain
////////////////////////////////////////////////////////////////////////////
func ValidateMember(stub *shim.ChaincodeStub, owner string) ([]byte, error) {

	// Get the Item Objects and Display it
	// Avalbytes, err := stub.GetState(owner)
	args := []string{owner, "USER"}
	Avalbytes, err := QueryLedger(stub, "UserTable", args)

	if err != nil {
		fmt.Printf("ValidateMember() : Failed - Cannot find valid owner record for ART  " + owner + "\n")
		jsonResp := "{\"Error\":\"Failed to get Owner Object Data for " + owner + "\"}"
		return nil, errors.New(jsonResp)
	}

	if Avalbytes == nil {
		fmt.Printf("ValidateMember() : Failed - Incomplete owner record for ART  " + owner + "\n")
		jsonResp := "{\"Error\":\"Failed - Incomplete information about the owner for " + owner + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Printf("ValidateMember() : Validated Item Owner:\n", owner)
	return Avalbytes, nil
}

////////////////////////////////////////////////////////////////////////////
// Validate if the User Information Exists
// in the block-chain
////////////////////////////////////////////////////////////////////////////
func ValidateItemSubmission(stub *shim.ChaincodeStub, artId string) ([]byte, error) {

	// Get the Item Objects and Display it
	args := []string{artId, "ARTINV"}
	Avalbytes, err := QueryLedger(stub, "ItemTable", args)
	if err != nil {
		fmt.Printf("ValidateItemSubmission() : Failed - Cannot find valid owner record for ART  " + artId + "\n")
		jsonResp := "{\"Error\":\"Failed to get Owner Object Data for " + artId + "\"}"
		return nil, errors.New(jsonResp)
	}

	if Avalbytes == nil {
		fmt.Printf("ValidateItemSubmission() : Failed - Incomplete owner record for ART  " + artId + "\n")
		jsonResp := "{\"Error\":\"Failed - Incomplete information about the owner for " + artId + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Printf("ValidateItemSubmission() : Validated Item Owner:%s\n", Avalbytes)
	return Avalbytes, nil
}

////////////////////////////////////////////////////////////////////////////
// Open a Ledgers if one does not exist
// These ledgers will be used to write /  read data
// Use names are listed in aucTables {}
////////////////////////////////////////////////////////////////////////////
func InitLedger(stub *shim.ChaincodeStub, tableName string) error {

	// Generic Table Creation Function - requires Table Name and Table Key Entry
	// Create Table - Get number of Keys the tables supports
	// This version assumes all Keys are String and the Data is Bytes
	// This Function can replace all other InitLedger function in this app such as InitItemLedger()

	nKeys := GetNumberOfKeys(tableName)
	if nKeys < 1 {
		fmt.Printf("Atleast 1 Key must be provided \n")
		fmt.Printf("Auction_Application: Failed creating Table ", tableName)
		return errors.New("Auction_Application: Failed creating Table " + tableName)
	}

	var columnDefsForTbl []*shim.ColumnDefinition

	for i := 0; i < nKeys; i++ {
		columnDef := shim.ColumnDefinition{Name: "keyName" + strconv.Itoa(i), Type: shim.ColumnDefinition_STRING, Key: true}
		columnDefsForTbl = append(columnDefsForTbl, &columnDef)
	}

	columnLastTblDef := shim.ColumnDefinition{Name: "Details", Type: shim.ColumnDefinition_BYTES, Key: false}
	columnDefsForTbl = append(columnDefsForTbl, &columnLastTblDef)

	// Create the Table (Nil is returned if the Table exists or if the table is created successfully
	err := stub.CreateTable(tableName, columnDefsForTbl)

	if err != nil {
		fmt.Printf("Auction_Application: Failed creating Table ", tableName)
		return errors.New("Auction_Application: Failed creating Table " + tableName)
	}

	return err
}

////////////////////////////////////////////////////////////////////////////
// Open a Ledgers if one does not exist
// These ledgers will be used to write /  read data
// Use names are listed in aucTables {}
////////////////////////////////////////////////////////////////////////////
func InitUserReg(stub *shim.ChaincodeStub) error {

	// Create Item Ledger table
	err := stub.CreateTable("UserTable", []*shim.ColumnDefinition{
		&shim.ColumnDefinition{"User", shim.ColumnDefinition_STRING, true},
		&shim.ColumnDefinition{"Details", shim.ColumnDefinition_BYTES, false},
	})

	if err != nil {
		fmt.Printf("Auction_Application: Failed creating Table ", "UserTable")
		return errors.New("Auction_Application: Failed creating Table " + "UserTable")
	}

	return err
}

////////////////////////////////////////////////////////////////////////////
// Open a Ledgers if one does not exist
// These ledgers will be used to write /  read data
// Use names are listed in aucTables {}
////////////////////////////////////////////////////////////////////////////
func InitAucReg(stub *shim.ChaincodeStub) error {

	// Create Item Ledger table
	err := stub.CreateTable("AuctionTable", []*shim.ColumnDefinition{
		&shim.ColumnDefinition{"AuctionID", shim.ColumnDefinition_STRING, true},
		&shim.ColumnDefinition{"Details", shim.ColumnDefinition_BYTES, false},
	})

	if err != nil {
		fmt.Printf("Auction_Application: Failed creating Auction Table ")
		return errors.New("Auction_Application: Failed creating Auction Table ")
	}

	return err
}

////////////////////////////////////////////////////////////////////////////
// Open a Ledgers if one does not exist
// These ledgers will be used to write /  read data
// Use names are listed in Bid {}
////////////////////////////////////////////////////////////////////////////
func InitBidReg(stub *shim.ChaincodeStub) error {

	// Create Item Ledger table
	err := stub.CreateTable("BidTable", []*shim.ColumnDefinition{
		&shim.ColumnDefinition{"AuctionID", shim.ColumnDefinition_STRING, true},
		&shim.ColumnDefinition{"BidNum", shim.ColumnDefinition_STRING, true},
		&shim.ColumnDefinition{"Details", shim.ColumnDefinition_BYTES, false},
	})

	if err != nil {
		fmt.Printf("Auction_Application: Failed creating Bid Table ")
		return errors.New("Auction_Application: Failed creating Bid Table ")
	}

	return err
}

////////////////////////////////////////////////////////////////////////////
// Open a Ledgers if one does not exist
// These ledgers will be used to write /  read data
// Use names are listed in aucTables {}
////////////////////////////////////////////////////////////////////////////
func InitTransReg(stub *shim.ChaincodeStub) error {

	// Create Item Ledger table
	err := stub.CreateTable("TransTable", []*shim.ColumnDefinition{
		&shim.ColumnDefinition{"AuctionID", shim.ColumnDefinition_STRING, true},
		&shim.ColumnDefinition{"ItemID", shim.ColumnDefinition_STRING, true},
		&shim.ColumnDefinition{"Details", shim.ColumnDefinition_BYTES, false},
	})

	if err != nil {
		fmt.Printf("Auction_Application: Failed creating Transaction Table ")
		return errors.New("Auction_Application: Failed creating Transaction Table ")
	}

	return err
}

////////////////////////////////////////////////////////////////////////////
// Open a Ledgers if one does not exist
// These ledgers will be used to write /  read data
// Use names are listed in aucTables {}
////////////////////////////////////////////////////////////////////////////
func InitItemMaster(stub *shim.ChaincodeStub) error {

	// Create Item Ledger table
	err := stub.CreateTable("ItemTable", []*shim.ColumnDefinition{
		&shim.ColumnDefinition{"Item", shim.ColumnDefinition_STRING, true},
		&shim.ColumnDefinition{"Details", shim.ColumnDefinition_BYTES, false},
	})

	if err != nil {
		fmt.Printf("Auction_Application: Failed creating Item Table")
		return errors.New("Auction_Application: Failed creating Item Table")
	}

	return err
}

////////////////////////////////////////////////////////////////////////////
// Open a Ledgers if one does not exist
// These ledgers will be used to write /  read data
// Use names are listed in aucTables {}
////////////////////////////////////////////////////////////////////////////
func InitItemReg(stub *shim.ChaincodeStub) error {

	// Create Item Ledger table
	err := stub.CreateTable("ItemHistoryTable", []*shim.ColumnDefinition{
		&shim.ColumnDefinition{"Item", shim.ColumnDefinition_STRING, true},
		&shim.ColumnDefinition{"Status", shim.ColumnDefinition_STRING, true},
		&shim.ColumnDefinition{"AucHouse", shim.ColumnDefinition_STRING, true},
		&shim.ColumnDefinition{"Details", shim.ColumnDefinition_BYTES, false},
	})

	if err != nil {
		fmt.Printf("Auction_Application: Failed creating Item Register")
		return errors.New("Auction_Application: Failed creating Item Register")
	}

	return err
}

////////////////////////////////////////////////////////////////////////////
// Open a Ledgers if one does not exist
// These ledgers will be used to write /  read data
// Use names are listed in aucTables {}
////////////////////////////////////////////////////////////////////////////
func InitIBidReg(stub *shim.ChaincodeStub) error {

	// Create Item Ledger table
	err := stub.CreateTable("BidTable", []*shim.ColumnDefinition{
		&shim.ColumnDefinition{"AuctionID", shim.ColumnDefinition_STRING, true},
		&shim.ColumnDefinition{"BidID", shim.ColumnDefinition_STRING, true},
		&shim.ColumnDefinition{"Details", shim.ColumnDefinition_BYTES, false},
	})

	if err != nil {
		fmt.Printf("Auction_Application: Failed creating Item Register")
		return errors.New("Auction_Application: Failed creating Item Register")
	}

	return err
}

////////////////////////////////////////////////////////////////////////////
// Open a Ledgers if one does not exist
// These ledgers will be used to write /  read data
// Use names are listed in aucTables {}
////////////////////////////////////////////////////////////////////////////
func InitAucTriggerReg(stub *shim.ChaincodeStub) error {

	// Create Item Ledger table
	err := stub.CreateTable("AucTriggerTable", []*shim.ColumnDefinition{
		&shim.ColumnDefinition{"AuctionID", shim.ColumnDefinition_STRING, true},
		&shim.ColumnDefinition{"AucStartDt", shim.ColumnDefinition_STRING, true},
		&shim.ColumnDefinition{"AucEndDt", shim.ColumnDefinition_STRING, true},
		&shim.ColumnDefinition{"Details", shim.ColumnDefinition_BYTES, false},
	})

	if err != nil {
		fmt.Printf("Auction_Application: Failed creating Item Register")
		return errors.New("Auction_Application: Failed creating Item Register")
	}

	return err
}

////////////////////////////////////////////////////////////////////////////
// Open a User Registration Table if one does not exist
// Register users into this table
////////////////////////////////////////////////////////////////////////////
func UpdateLedger(stub *shim.ChaincodeStub, tableName string, keys []string, args []byte) error {

	nKeys := GetNumberOfKeys(tableName)
	if nKeys < 1 {
		fmt.Printf("Atleast 1 Key must be provided \n")
	}

	var columns []*shim.Column

	for i := 0; i < nKeys; i++ {
		col := shim.Column{Value: &shim.Column_String_{String_: keys[i]}}
		columns = append(columns, &col)
	}

	lastCol := shim.Column{Value: &shim.Column_Bytes{Bytes: []byte(args)}}
	columns = append(columns, &lastCol)

	row := shim.Row{columns}
	ok, err := stub.InsertRow(tableName, row)
	if err != nil {
		return fmt.Errorf("UpdateLedger: InsertRow into "+tableName+" Table operation failed. %s", err)
	}
	if !ok {
		return errors.New("UpdateLedger: InsertRow into " + tableName + " Table failed. Row with given key " + keys[0] + " already exists")
	}

	fmt.Printf("UpdateLedger: InsertRow into " + tableName + " Table operation Successful. ")
	return nil
}

////////////////////////////////////////////////////////////////////////////
// Open a User Registration Table if one does not exist
// Register users into this table
////////////////////////////////////////////////////////////////////////////
func DeleteFromLedger(stub *shim.ChaincodeStub, tableName string, keys []string) error {
	var columns []shim.Column

	//nKeys := GetNumberOfKeys(tableName)
	nCol := len(keys)
	if nCol < 1 {
		fmt.Printf("Atleast 1 Key must be provided \n")
		return errors.New("GetList failed. Must include at least key values")
	}

	for i := 0; i < nCol; i++ {
		colNext := shim.Column{Value: &shim.Column_String_{String_: keys[i]}}
		columns = append(columns, colNext)
	}

	err := stub.DeleteRow(tableName, columns)
	if err != nil {
		return fmt.Errorf("DeleteFromLedger operation failed. %s", err)
	}

	fmt.Println("DeleteFromLedger: DeleteRow from " + tableName + " Table operation Successful. ")
	return nil
}

////////////////////////////////////////////////////////////////////////////
// Replaces the Entry in the Ledger
//
////////////////////////////////////////////////////////////////////////////
func ReplaceLedgerEntry(stub *shim.ChaincodeStub, tableName string, keys []string, args []byte) error {

	nKeys := GetNumberOfKeys(tableName)
	if nKeys < 1 {
		fmt.Printf("Atleast 1 Key must be provided \n")
	}

	var columns []*shim.Column

	for i := 0; i < nKeys; i++ {
		col := shim.Column{Value: &shim.Column_String_{String_: keys[i]}}
		columns = append(columns, &col)
	}

	lastCol := shim.Column{Value: &shim.Column_Bytes{Bytes: []byte(args)}}
	columns = append(columns, &lastCol)

	row := shim.Row{columns}
	ok, err := stub.ReplaceRow(tableName, row)
	if err != nil {
		return fmt.Errorf("ReplaceLedgerEntry: ReplaceRoq into "+tableName+" Table operation failed. %s", err)
	}
	if !ok {
		return errors.New("ReplaceLedgerEntry: ReplaceRoq into " + tableName + " Table failed. Row with given key " + keys[0] + " already exists")
	}

	fmt.Printf("ReplaceLedgerEntry: Replace Row in " + tableName + " Table operation Successful. ")
	return nil
}

////////////////////////////////////////////////////////////////////////////
// Query a User Object by Table Name and Key
////////////////////////////////////////////////////////////////////////////
func QueryLedger(stub *shim.ChaincodeStub, tableName string, args []string) ([]byte, error) {

	var columns []shim.Column
	nCol := GetNumberOfKeys(tableName)
	for i := 0; i < nCol; i++ {
		colNext := shim.Column{Value: &shim.Column_String_{String_: args[i]}}
		columns = append(columns, colNext)
	}

	row, err := stub.GetRow(tableName, columns)
	fmt.Printf("Length or number of rows retrieved ", len(row.Columns))

	if len(row.Columns) == 0 {
		jsonResp := "{\"Error\":\"Failed retrieving data " + args[0] + ". \"}"
		fmt.Printf("Error retrieving data record for Key = ", args[0], "Error : ", jsonResp)
		return nil, errors.New(jsonResp)
	}

	/*fmt.Printf("User Query Response:\n", row)
	jsonResp := "{\"Owner\":\"" + string(row.Columns[nCol].GetBytes()) + "\"}"
	fmt.Printf("User Query Response:%s\n", jsonResp)*/

	Avalbytes := row.Columns[nCol].GetBytes()

	// Perform Any additional processing of data
	fmt.Printf("QueryLedger() : Successful - Proceeding to ProcessRequestType ")
	err = ProcessQueryResult(stub, Avalbytes, args)
	if err != nil {
		fmt.Printf("QueryLedger() : Cannot create object  : " + args[1] + "\n")
		jsonResp := "{\"QueryLedger() Error\":\" Cannot create Object for key " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	return Avalbytes, nil
}

////////////////////////////////////////////////////////////////////////////
// Get List of Bids for an Auction
// in the block-chain
////////////////////////////////////////////////////////////////////////////
func GetListOfBids(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	rows, err := GetList(stub, "BidTable", args)
	if err != nil {
		return nil, fmt.Errorf("GetListOfBids operation failed. Error marshaling JSON: %s", err)
	}

	nCol := GetNumberOfKeys("BidTable")

	tlist := make([]Bid, len(rows))
	for i := 0; i < len(rows); i++ {
		ts := rows[i].Columns[nCol].GetBytes()
		bid, err := JSONtoBid(ts)
		if err != nil {
			fmt.Printf("GetListOfBids() Failed : Ummarshall error")
			return nil, fmt.Errorf("GetListOfBids() operation failed. %s", err)
		}
		tlist[i] = bid
	}

	jsonRows, _ := json.Marshal(tlist)

	//fmt.Printf("All Bids : ", jsonRows)
	return jsonRows, nil

}

////////////////////////////////////////////////////////////////////////////
// Get List of Auctions that have been initiated
// in the block-chain
////////////////////////////////////////////////////////////////////////////
func GetListOfItemsOnAuc(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	rows, err := GetList(stub, "AucInitTable", args)
	if err != nil {
		return nil, fmt.Errorf("GetListOfItemsOnAuc operation failed. Error marshaling JSON: %s", err)
	}

	nCol := GetNumberOfKeys("AucInitTable")

	tlist := make([]AuctionRequest, len(rows))
	for i := 0; i < len(rows); i++ {
		ts := rows[i].Columns[nCol].GetBytes()
		ar, err := JSONtoAucReq(ts)
		if err != nil {
			fmt.Printf("getBillForMonth() Failed : Ummarshall error")
			return nil, fmt.Errorf("getBillForMonth() operation failed. %s", err)
		}
		tlist[i] = ar
	}

	jsonRows, _ := json.Marshal(tlist)

	fmt.Printf("List of Auctions Requested : ", jsonRows)
	return jsonRows, nil

}

////////////////////////////////////////////////////////////////////////////
// Get List of Open Auctions  for which bids can be supplied
// in the block-chain
////////////////////////////////////////////////////////////////////////////
func GetListOfOpenAucs(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	rows, err := GetList(stub, "AucOpenTable", args)
	if err != nil {
		return nil, fmt.Errorf("GetListOfOpenAucs operation failed. Error marshaling JSON: %s", err)
	}

	nCol := GetNumberOfKeys("AucOpenTable")

	tlist := make([]AuctionRequest, len(rows))
	for i := 0; i < len(rows); i++ {
		ts := rows[i].Columns[nCol].GetBytes()
		ar, err := JSONtoAucReq(ts)
		if err != nil {
			fmt.Printf("GetListOfOpenAucs() Failed : Ummarshall error")
			return nil, fmt.Errorf("GetListOfOpenAucs() operation failed. %s", err)
		}
		tlist[i] = ar
	}

	jsonRows, _ := json.Marshal(tlist)

	fmt.Printf("List of Open Auctions : ", jsonRows)
	return jsonRows, nil

}

////////////////////////////////////////////////////////////////////////////
// Validate Query Result
// in the block-chain
////////////////////////////////////////////////////////////////////////////
func GetItemLog(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	// Check there are 1 Arguments provided as per the the struct - two are computed
	// See example
	if len(args) < 1 {
		fmt.Println("GetItemLog(): Incorrect number of arguments. Expecting 1 ")
		fmt.Println("GetItemLog(): ./peer chaincode query -l golang -n mycc -c '{\"Function\": \"GetItem\", \"Args\": [\"1111\"]}'")
		return nil, errors.New("CreateItemObject(): Incorrect number of arguments. Expecting 12 ")
	}

	rows, err := GetList(stub, "ItemHistoryTable", args)
	jsonRows, err := json.Marshal(rows)
	if err != nil {
		return nil, fmt.Errorf("GetItemLog() operation failed. Error marshaling JSON: %s", err)
	}

	//fmt.Printf("All Bids : ", jsonRows)
	return jsonRows, nil

}

////////////////////////////////////////////////////////////////////////////
// Get a List of Items by Category
// in the block-chain
////////////////////////////////////////////////////////////////////////////
func GetItemListByCat(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	// Check there are 1 Arguments provided as per the the struct - two are computed
	// See example
	if len(args) < 1 {
		fmt.Println("GetItemListByCat(): Incorrect number of arguments. Expecting 1 ")
		fmt.Println("GetItemListByCat(): ./peer chaincode query -l golang -n mycc -c '{\"Function\": \"GetItemListByCat\", \"Args\": [\"AUTO\"]}'")
		return nil, errors.New("CreateItemObject(): Incorrect number of arguments. Expecting 1 ")
	}

	rows, err := GetList(stub, "ItemCatTable", args)
	if err != nil {
		return nil, fmt.Errorf("GetItemListByCat() operation failed. Error GetList: %s", err)
	}

	nCol := GetNumberOfKeys("ItemCatTable")

	tlist := make([]ItemObject, len(rows))
	for i := 0; i < len(rows); i++ {
		ts := rows[i].Columns[nCol].GetBytes()
		io, err := JSONtoAR(ts)
		if err != nil {
			fmt.Printf("() Failed : Ummarshall error")
			return nil, fmt.Errorf("GetItemListByCat() operation failed. %s", err)
		}
		tlist[i] = io
	}

	jsonRows, _ := json.Marshal(tlist)

	//fmt.Printf("All Items : ", jsonRows)
	return jsonRows, nil

}

////////////////////////////////////////////////////////////////////////////
// Get a List of Users by Category
// in the block-chain
////////////////////////////////////////////////////////////////////////////
func GetUserListByCat(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	// Check there are 1 Arguments provided as per the the struct - two are computed
	// See example
	if len(args) < 1 {
		fmt.Println("GetUserListByCat(): Incorrect number of arguments. Expecting 1 ")
		fmt.Println("GetUserListByCat(): ./peer chaincode query -l golang -n mycc -c '{\"Function\": \"GetUserListByCat\", \"Args\": [\"AH\"]}'")
		return nil, errors.New("CreateUserObject(): Incorrect number of arguments. Expecting 1 ")
	}

	rows, err := GetList(stub, "UserCatTable", args)
	if err != nil {
		return nil, fmt.Errorf("GetUserListByCat() operation failed. Error marshaling JSON: %s", err)
	}

	nCol := GetNumberOfKeys("UserCatTable")

	tlist := make([]UserObject, len(rows))
	for i := 0; i < len(rows); i++ {
		ts := rows[i].Columns[nCol].GetBytes()
		uo, err := JSONtoUser(ts)
		if err != nil {
			fmt.Printf("GetUserListByCat() Failed : Ummarshall error")
			return nil, fmt.Errorf("GetUserListByCat() operation failed. %s", err)
		}
		tlist[i] = uo
	}

	jsonRows, _ := json.Marshal(tlist)

	//fmt.Printf("All Users : ", jsonRows)
	return jsonRows, nil

}

////////////////////////////////////////////////////////////////////////////
// Get a List of Rows based on query criteria from the OBC
//
////////////////////////////////////////////////////////////////////////////
func GetList(stub *shim.ChaincodeStub, tableName string, args []string) ([]shim.Row, error) {
	var columns []shim.Column

	nKeys := GetNumberOfKeys(tableName)
	nCol := len(args)
	if nCol < 1 {
		fmt.Printf("Atleast 1 Key must be provided \n")
		return nil, errors.New("GetList failed. Must include at least key values")
	}

	for i := 0; i < nCol; i++ {
		colNext := shim.Column{Value: &shim.Column_String_{String_: args[i]}}
		columns = append(columns, colNext)
	}

	rowChannel, err := stub.GetRows(tableName, columns)
	if err != nil {
		return nil, fmt.Errorf("GetList operation failed. %s", err)
	}
	var rows []shim.Row
	for {
		select {
		case row, ok := <-rowChannel:
			if !ok {
				rowChannel = nil
			} else {
				rows = append(rows, row)
				//fmt.Println(row)
			}
		}
		if rowChannel == nil {
			break
		}
	}

	fmt.Println("Number of Keys retrieved : ", nKeys)
	fmt.Println("Number of rows retrieved : ", len(rows))
	return rows, nil
}

////////////////////////////////////////////////////////////////////////////
// Get The Highest Bid Received so far for an Auction
// in the block-chain
////////////////////////////////////////////////////////////////////////////
func GetLastBid(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	tn := "BidTable"
	rows, err := GetList(stub, tn, args)
	if err != nil {
		return nil, fmt.Errorf("GetLastBid operation failed. %s", err)
	}
	nCol := GetNumberOfKeys(tn)
	var Avalbytes []byte
	var dat map[string]interface{}
	layout := "2006-01-02 15:04:05"
	highestTime, err := time.Parse(layout, layout)

	for i := 0; i < len(rows); i++ {
		currentBid := rows[i].Columns[nCol].GetBytes()
		if err := json.Unmarshal(currentBid, &dat); err != nil {
			fmt.Printf("GetHighestBid() Failed : Ummarshall error")
			return nil, fmt.Errorf("GetHighestBid(0 operation failed. %s", err)
		}
		bidTime, err := time.Parse(layout, dat["BidTime"].(string))
		if err != nil {
			fmt.Printf("GetLastBid() Failed : time Conversion error on BidTime")
			return nil, fmt.Errorf("GetHighestBid() Int Conversion error on BidPrice! failed. %s", err)
		}

		if bidTime.Sub(highestTime) > 0 {
			highestTime = bidTime
			Avalbytes = currentBid
		}
	}

	return Avalbytes, nil

}

////////////////////////////////////////////////////////////////////////////
// Get The Highest Bid Received so far for an Auction
// in the block-chain
////////////////////////////////////////////////////////////////////////////
func GetNoOfBidsReceived(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	tn := "BidTable"
	rows, err := GetList(stub, tn, args)
	if err != nil {
		return nil, fmt.Errorf("GetLastBid operation failed. %s", err)
	}
	nBids := len(rows)
	return []byte(strconv.Itoa(nBids)), nil
}

////////////////////////////////////////////////////////////////////////////
// Get the Highest Bid in the List
//
////////////////////////////////////////////////////////////////////////////
func GetHighestBid(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	tn := "BidTable"
	rows, err := GetList(stub, tn, args)
	if err != nil {
		return nil, fmt.Errorf("GetLastBid operation failed. %s", err)
	}
	nCol := GetNumberOfKeys(tn)
	var Avalbytes []byte
	var dat map[string]interface{}
	var bidPrice, highestBid int
	highestBid = 0

	for i := 0; i < len(rows); i++ {
		currentBid := rows[i].Columns[nCol].GetBytes()
		if err := json.Unmarshal(currentBid, &dat); err != nil {
			fmt.Printf("GetHighestBid() Failed : Ummarshall error")
			return nil, fmt.Errorf("GetHighestBid(0 operation failed. %s", err)
		}
		bidPrice, err = strconv.Atoi(dat["BidPrice"].(string))
		if err != nil {
			fmt.Printf("GetHighestBid() Failed : Int Conversion error on BidPrice")
			return nil, fmt.Errorf("GetHighestBid() Int Conversion error on BidPrice! failed. %s", err)
		}

		if bidPrice >= highestBid {
			highestBid = bidPrice
			Avalbytes = currentBid
		}
	}

	return Avalbytes, nil
}

//////////////////////////////////////////////////////////////////////////
// Return the right Object Buffer after validation to write to the ledger
// const recType [] string = {"ARTINV", "USER", "BUY", "SELL", "REG"}
//////////////////////////////////////////////////////////////////////////

func ProcessQueryResult(stub *shim.ChaincodeStub, Avalbytes []byte, args []string) error {

	var dat map[string]interface{}

	if err := json.Unmarshal(Avalbytes, &dat); err != nil {
		panic(err)
	}

	var recType string
	recType = dat["RecType"].(string)
	switch recType {

	case "ARTINV":

		ar, err := JSONtoAR(Avalbytes) //
		if err != nil {
			fmt.Printf("ProcessRequestType(): Cannot create itemObject \n")
			return err
		}

		// Decrypt Image and Save Image in a file
		image := Decrypt(ar.AES_Key, ar.ItemImage)
		if err != nil {
			fmt.Printf("ProcessRequestType() : Image decrytion failed ")
			return err
		}

		err = ByteArrayToImage(image, "copy."+ar.ItemPicFN)
		if err != nil {
			fmt.Printf("ProcessRequestType() : Image conversion from byte[] to file failed ")
			return err
		}
		return err

	case "USER":
		ur, err := JSONtoUser(Avalbytes) //
		if err != nil {
			return err
		}
		fmt.Printf("ProcessRequestType() : ", ur)
		return err

	case "AUCREQ":
		ar, err := JSONtoAucReq(Avalbytes) //
		if err != nil {
			return err
		}
		fmt.Printf("ProcessRequestType() : ", ar)
		return err
	case "OPENAUC":
		ar, err := JSONtoAucReq(Avalbytes) //
		if err != nil {
			return err
		}
		fmt.Printf("ProcessRequestType() : ", ar)
		return err
	case "CLAUC":
		ar, err := JSONtoAucReq(Avalbytes) //
		if err != nil {
			return err
		}
		fmt.Printf("ProcessRequestType() : ", ar)
		return err
	case "POSTTRAN":
		atr, err := JSONtoTran(Avalbytes) //
		if err != nil {
			return err
		}
		fmt.Printf("ProcessRequestType() : ", atr)
		return err
	case "BID":
		bid, err := JSONtoBid(Avalbytes) //
		if err != nil {
			return err
		}
		fmt.Printf("ProcessRequestType() : ", bid)
		return err
	default:

		return errors.New("Unknown")
	}
	return nil

}

//////////////////////////////////////////////////////////////////////////
// Trigger the Auction
// Structure of args auctionReqID, RecType, Duration
//
//////////////////////////////////////////////////////////////////////////

func OpenAuctionForBids(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	// Fetch Auction Object
	Avalbytes, err := QueryLedger(stub, "AuctionTable", args)
	if err != nil {
		fmt.Println("OpenAuctionForBids(): Auction Object Retrieval Failed ")
		return nil, errors.New("OpenAuctionForBids(): Auction Object Retrieval Failed ")
	}

	aucR, err := JSONtoAucReq(Avalbytes)
	if err != nil {
		fmt.Println("OpenAuctionForBids(): Auction Object Unmarshalling Failed ")
		return nil, errors.New("OpenAuctionForBids(): Auction Object UnMarshalling Failed ")
	}

	if aucR.Status == "CLOSED" {
		fmt.Println("OpenAuctionForBids(): Auction is Closed - Cannot Open for new bids ")
		return nil, errors.New("OpenAuctionForBids(): is Closed - Cannot Open for new bids Failed ")
	}

	// Calculate Time Now and Duration of Auction

	// Validate arg[1]  is an integer as it represents Duration in Minutes
	aucDuration, err := strconv.Atoi(args[2])
	if err != nil {
		fmt.Println("OpenAuctionForBids(): Auction Duration is an integer that represents minute! OpenAuctionForBids() Failed ")
		return nil, errors.New("OpenAuctionForBids(): Auction Duration is an integer that represents minute! OpenAuctionForBids() Failed ")
	}

	aucStartDate := time.Now()
	aucEndDate := aucStartDate.Add(time.Duration(aucDuration) * time.Minute)
	sleepTime := time.Duration(aucDuration * 60 * 1000 * 1000 * 1000)

	//  Update Auction Object
	aucR.OpenDate = aucStartDate.Format("2006-01-02 15:04:05")
	aucR.CloseDate = aucEndDate.Format("2006-01-02 15:04:05")
	aucR.Status = "OPEN"

	buff, err := UpdateAuctionStatus(stub, "AuctionTable", aucR)
	if err != nil {
		fmt.Println("OpenAuctionForBids(): UpdateAuctionStatus() Failed ")
		return nil, errors.New("OpenAuctionForBids(): UpdateAuctionStatus() Failed ")
	}

	// Remove the Auction from Init Bucket
	keys := []string{"2016", aucR.AuctionID}
	err = DeleteFromLedger(stub, "AucInitTable", keys)
	if err != nil {
		fmt.Println("OpenAuctionForBids(): DeleteFromLedger() Failed ")
		return nil, errors.New("OpenAuctionForBids(): DeleteFromLedger() Failed ")
	}

	// Add the Auction to Open Bucket
	err = UpdateLedger(stub, "AucOpenTable", keys, buff)
	if err != nil {
		fmt.Printf("OpenAuctionForBids() : write error while inserting record into AucInitTable \n")
		return buff, err
	}

	// Initiate Timer
	go func(aucR AuctionRequest, sleeptime time.Duration) ([]byte, error) {
		//c := make(chan string, 2)
		fmt.Println("OpenAuctionForBids(): Sleeping for ", sleeptime)
		time.Sleep(sleeptime)

		// Exec The following Command from the shell
		ShellCmdToCloseAuction(aucR.AuctionID)
		return nil, err
	}(aucR, sleepTime)
	return buff, err
}

//////////////////////////////////////////////////////////////////////////
// Create a Command to execute Close Auction From the Command line
//
//////////////////////////////////////////////////////////////////////////
func ShellCmdToCloseAuction(aucID string) error {

	cdir := "cd /opt/gopath/src/github.com/hyperledger/fabric/"
	argStr := "'{\"Function\": \"CloseAuction\", \"Args\": [\"" + aucID + "\"," + "\"AUCREQ\"" + "]}'"
	argStr = "/opt/gopath/src/github.com/hyperledger/fabric/peer chaincode invoke -l golang -n mycc -c " + argStr

	fileHandle, _ := os.Create("/opt/gopath/src/github.com/hyperledger/fabric/closeauction.sh")
	writer := bufio.NewWriter(fileHandle)
	defer fileHandle.Close()

	fmt.Fprintln(writer, cdir)
	fmt.Fprintln(writer, argStr)
	writer.Flush()

	x := "sh /opt/gopath/src/github.com/hyperledger/fabric/closeauction.sh"
	err := exe_cmd(x)
	if err != nil {
		fmt.Printf("%s", err)
	}

	err = exe_cmd("rm /opt/gopath/src/github.com/hyperledger/fabric/closeauction.sh")
	if err != nil {
		fmt.Printf("%s", err)
	}

	fmt.Println("Kicking off CloseAuction", argStr)
	return nil
}

func exe_cmd(cmd string) error {

	fmt.Println("command :  ", cmd)
	parts := strings.Fields(cmd)
	head := parts[0]
	parts = parts[1:len(parts)]

	_, err := exec.Command(head, parts...).CombinedOutput()
	if err != nil {
		fmt.Printf("%s", err)
	}
	return err
}

//////////////////////////////////////////////////////////////////////////
// Close the Auction
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "CloseAuction", "Args": ["1111", "AUCREQ"]}'
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "CloseAuction", "Args": ["1111", "AUCREQ"]}'
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "PostBid", "Args":["1111","CLAUC"]}'
//
//////////////////////////////////////////////////////////////////////////

func CloseAuction(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	// Close The Auction -  Fetch Auction Object
	Avalbytes, err := QueryLedger(stub, "AuctionTable", []string{args[0], "AUCREQ"})
	if err != nil {
		fmt.Println("CloseAuction(): Auction Object Retrieval Failed ")
		return nil, errors.New("CloseAuction(): Auction Object Retrieval Failed ")
	}

	aucR, err := JSONtoAucReq(Avalbytes)
	if err != nil {
		fmt.Println("CloseAuction(): Auction Object Unmarshalling Failed ")
		return nil, errors.New("CloseAuction(): Auction Object UnMarshalling Failed ")
	}

	//  Update Auction Status
	aucR.Status = "CLOSED"
	fmt.Println("CloseAuction(): UpdateAuctionStatus() successful ", aucR)

	Avalbytes, err = UpdateAuctionStatus(stub, "AuctionTable", aucR)
	if err != nil {
		fmt.Println("CloseAuction(): UpdateAuctionStatus() Failed ")
		return nil, errors.New("OpenAuctionForBids(): UpdateAuctionStatus() Failed ")
	}

	// Remove the Auction from Open Bucket
	keys := []string{"2016", aucR.AuctionID}
	err = DeleteFromLedger(stub, "AucOpenTable", keys)
	if err != nil {
		fmt.Println("CloseAuction(): DeleteFromLedger() Failed ")
		return nil, errors.New("OpenAuctionForBids(): DeleteFromLedger() Failed ")
	}

	fmt.Println("CloseAuction(): UpdateAuctionStatus() successful ", Avalbytes)
	fmt.Println("CloseAuction(): Proceeding to process the highest bid ")

	// Process Final Bid - Turn it into a Transaction
	Avalbytes, err = GetHighestBid(stub, "GetHighestBid", []string{args[0]})
	bid, _ := JSONtoBid(Avalbytes)
	fmt.Println("OpenAuctionForBids(): Proceeding to process the highest bid ", bid)
	fmt.Println("OpenAuctionForBids(): Converting Bid to Tran ")
	tran := BidtoTransaction(bid)
	fmt.Println("OpenAuctionForBids(): Converting bid to tran ", tran)

	// Process the last bid once Time Expires
	tranArgs := []string{tran.AuctionID, tran.RecType, tran.ItemID, tran.TransType, tran.UserId, tran.TransDate, tran.HammerTime, tran.HammerPrice, tran.Details}
	fmt.Println("OpenAuctionForBids(): Proceeding to process the  Transaction ", tranArgs)

	Avalbytes, err = PostTransaction(stub, "PostTransaction", tranArgs)
	if err != nil {
		fmt.Println("CloseAuction(): PostTransaction() Failed ")
		return nil, errors.New("CloseAuction(): PostTransaction() Failed ")
	}
	fmt.Println("CloseAuction(): PostTransaction() Completed Successfully ")
	return Avalbytes, nil
}

//////////////////////////////////////////////////////////////////////////
// Update the Auction Object
//
//////////////////////////////////////////////////////////////////////////

func UpdateAuctionStatus(stub *shim.ChaincodeStub, tableName string, ar AuctionRequest) ([]byte, error) {

	buff, err := AucReqtoJSON(ar) //
	if err != nil {
		fmt.Printf("UpdateAuctionStatus() : Failed Cannot create object buffer for write : " + ar.AuctionID + "\n")
		return nil, errors.New("UpdateAuctionStatus(): Failed Cannot create object buffer for write : " + ar.AuctionID)
	}

	// Update the ledger with the Buffer Data
	keys := []string{ar.AuctionID, ar.ItemID}
	err = ReplaceLedgerEntry(stub, "AuctionTable", keys, buff)
	if err != nil {
		fmt.Printf("UpdateAuctionStatus() : write error while inserting record\n")
		return buff, err
	}
	return buff, err
}
